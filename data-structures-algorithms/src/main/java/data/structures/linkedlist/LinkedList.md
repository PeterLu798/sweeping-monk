# 链表
## 01 哈希表
【题目】认识Java中的无序哈希表和有序哈希表
## 02 反转单向和双向链表
【题目】分别实现反转单向链表和双向链表的函数  
【要求】如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)   
一、反转单链表   
方案一：原地反转     
1. 定义两个指针，beg指针指向首节点（注意不一定是头节点），end指向首节点的下一个节点，即：   
Node beg = head.next;   
Node end = head.next.next;   
2. 现在开始反转beg和end，但是为了防止end后面的节点丢失，先吧end后面的节点保存到beg.next中，即   
beg.next = end.next;   
3. end掉头去连接首节点，即将head.next保存到end.next中   
end.next = head.next   
4. 头节点接end节点   
head.next = end;   
5. 保持end在beg的后面，因此移动end   
end = beg.next;   
6. 以上2、3、4、5四步总结为连、掉、接、移
7. 重复2——5四步，直到end为null   

方案二：头插法     
1. 先将头断链，但是为了防止断链后找不到后面的节点，先定义一个指针p，p指向head.next，即   
Node p = head.next;  
head.next = null;//头节点断链  
2. 现在开始头插，将首节点插入到头节点后面，首节点的next指向null，但是为了防止首节点后的节点断链，先定义一个指针q，q指向p.next，即  
Node q = p.next;//暂存p的后继  
//下面这两步就是将p插入到头节点之后  
p.next = head.next;//先断   
head.next = p;//再连   
3. p往后移动 
p = q;   
4. 重复2——3，直到p为null  

二、反转双链表  


## 03 打印两个有序链表的公共部分
【题目】给定两个有序链表的头指针head1和head2，打印两个链表的公共部分  
【要求】如果两个链表的长度之和为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)
## 04 判断一个链表是否是回文结构
【题目】给定一个单链表的头节点head，请判断该链表是否为回文结构  
【例子】什么是回文结构，例如：1->2->2->1、1->3->1都为回文结构  
【解题思路】     
方案一：使用栈结构，将整个链表放入栈中，然后循环遍历链表，从头节点开始，和栈中pop的元素做比较，如果有一个不相等的，则返回false，中止循环。如果都相等，那么就是回文结构，返回true.   
此方案的时间复杂度为O(N)，空间复杂度也为O(N)   
方案二：使用快慢指针   
1. 使用快慢指针遍历链表，如果链表的节点数为奇数个，那么当快指针走到链表结尾的时候，慢指针走到了中间节点；如果链表的节点数为偶数个，当快指针走到倒数第二个节点时，慢指针走到中线位置的前一个节点；   
2. 将链表的后半部分反转，反转完毕之后两个子链表长度一样   
3. 开始遍历两个链表并逐一比对，如果有不相等的情况则不是回文结构，并停止遍历   
4. 将链表恢复   
5. 返回结果      

## 05 将单向链表按某值划分成左边小，中间相等，右边大的形式   
【题目】给定一个单链表的头节点head，节点值的类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右边是大于pivot的节点。   
【要求】时间复杂度不能大于O(N)，空间复杂度为O(1)   
【解题思路】    
1. 申请6个指针，分别是   
Node sh = null;  //小于部分的首节点  
Node st = null;  //小于部分的尾节点  
Node eh = null;  //等于部分的首节点  
Node et = null;  //等于部分的尾节点   
Node bh = null;  //大于部分的首节点   
Node bt = null;  //大于部分的尾节点   
2. 开始遍历链表，遍历完成之后将小于pivot的节点归到了以st开头、st结尾的子链表中，将等于pivot的节点归到了以eh开头、et结尾的子链表中，将大于pivot的节点归到了以bh开头、bt结尾的子链表中   
3. 将st与eh连起来、et与bh连起来就组成了符合题目要求的链表   

## 06 复制含有一个随机指针节点的链表   
【题目】一种特殊的单链表节点类描述如下：    
class Node {   
  int value;  
  Node next;  
  Node rand;   
}   
rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向Null。给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。   
【要求】时间复杂度O(N)    
【解题思路】   
方案一：   
1. 遍历链表，将每一个节点拷贝一个新的节点，并将老节点和新节点放在HashMap中，老节点作为key，新节点作为value。  
2. 再次遍历链表，给新拷贝的链表复制next和rand指针         
3. 此方法的时间复杂度为O(N)，空间复杂度也为O(N)      

方案二：    
1. 遍历链表，将拷贝的新节点放在旧节点的后面，也就是作为旧节点的next   
2. 再次遍历链表，找到克隆节点的rand节点   
3. 最后一次遍历链表，将新老链表分离开   
    
## 07 两个单链表相交的一系列问题    
【题目】给定两个有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点，如果不相交返回null   
【要求】如果两个链表长度之和为N，时间复杂度不能超过O(N)，额外空间复杂度不能超过O(1)   
【解题思路】     
1. 首先实现一个函数，判断一个单链表没有没环，如果有环，则返回入环节点      
1.1 方法1：在不考虑额外空间复杂度的情况下，使用HashSet，遍历单链表，将每一个节点放入到HashSet中，但是在放之前先判断该节点是否在集合中，如果在，那么这个节点就是入环节点，结束循环。   
1.2 方法2：使用快慢指针，快指针一次走2步，慢指针一次走1步，如果是有环单链表，它们一定会在某处相遇，相遇后快指针回到头节点，然后一次走1步，当它们再次相遇后，该相遇点就是入环节点。该方法很魔性，证明很复杂。
2. 情况一：如果两个单链表都无环，那么有以下两种结果：   
2.1 两个单链表无环且彼此不相交    
2.2 两个单链表无环且相交      
如何判断是否相交？   
方法就是分别遍历两个单链表，直到最后一个节点，然后判断两个链表的最后一个节点是否相等，如果相等就是相交，如果不相等就是不相交；   
如果相交的情况下如何拿到第一个相交点？     
方法是在上面遍历两个单链表的时候分别计算它们的长度，然后计算长度差，假设为m。接下来先让较长链表从头开始遍历m步，此时第二个链表也开始从头遍历，它们的第一个交点就是第一个相交点    
3. 情况二：如果一个有环、一个无环，那么这两个单链表一定不相交    
4. 情况三：两个都有环，那么有以下三种结果：   
4.1 两个都有环且彼此不相交   
4.2 两个都有环且入环节点是同一个   
4.3 两个都有环且入环节点不是同一个   
假设两个有环单链表的第一个入环节点分别是 node1、node2，对于4.2的情况最好判断，就判断node1是否等于node2，如果相等就是4.2的情况；如果不相等则让node1继续向下遍历，在重新回到node1位置的过程中，如果能遇到node2就是4.3的情况，如果遇不到node2就是4.1的情况。    
对于4.2如何求第一个相交点？   
还是使用2.2中的方法，但是注意遍历的最后一个节点是入环节点   
对于4.3如何求第一个相交点？   
对于4.3情况下，返回node1或node2都可以，node1、node2都叫第一个相交点   



