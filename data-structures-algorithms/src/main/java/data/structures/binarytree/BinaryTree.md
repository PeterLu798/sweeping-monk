# 二叉树  
## 01 二叉树的遍历
### 递归序   
![img.png](img.png)    
使用递归的方式遍历上面这棵树，代码如下：   
```java
public void recursion(Node head) {
    if (head == null) {
        return;
    }
    recursion(head.left);
    recursion(head.right);
}
```
假如让程序一回到主方法就打印，那么用这段程序遍历上面这棵树其结果就是：   
1-2-3-3-3-2-4-4-4-2-1-5-6-6-6-5-7-7-7-5-1     
这就是递归序。     
### 递归序前序遍历
前序遍历顺序为：头->左->右（注意是对每一颗子树都是这样的顺序）   
上图这颗树的前序遍历应该为：1-2-3-4-5-6-7，也就是当每个节点在递归序中<font color=red>第一次</font>出现时打印。
### 递归序中序遍历
中序遍历顺序为：左->头->右（注意是对每一颗子树都是这样的顺序）   
上图这棵树的中序遍历应该为：3-2-4-1-6-5-7，也就是当每个节点在递归序中<font color=red>第二次</font>出现时打印。
### 递归序后序遍历
后序遍历顺序为：左->右->头（注意是对每一颗子树都是这样的顺序）       
上图这棵树的后序遍历应该为：3-4-2-6-7-5-1，也就是当每个节点在递归序中<font color=red>第三次</font>出现时打印。
### 非递归序前序遍历
1. 申明一个栈   
2. 将根节点入栈   
3. 从栈中弹出节点，打印   
4. 先将弹出节点的<font color=red>右孩子</font>入栈，再将左孩子入栈（注意先判断是否有左右孩子）   
5. 重复3——4步，直到栈为空     
### 非递归中序遍历
1. 申明一个栈
2. 将根节点压入栈，然后从根节点开始，只要有左孩子，将所有左孩子压入栈中  
3. 从栈中弹出一个节点，弹出打印   
4. 如果弹出节点有右孩子，对右孩子重复2——3过程  
5. 重复2——4步，直到栈为空或者到达最后一个节点
### 非递归后序遍历   
1. 申明2个栈s1和s2  
2. 将根节点加入s1栈中    
3. 从s1栈中弹出节点，加入s2栈中   
4. 先将弹出节点的<font color=red>左孩子</font>入栈s1，再将右孩子入栈s1（注意先判断是否有左右孩子）  
5. 重复3——4步，直到栈为空   
6. 将s2依次弹出打印     
### 二叉树宽度优先遍历
1. 申明一个队列
2. 将根节点放入队列中  
3. 从队列中弹出一个节点，弹出打印  
4. 将弹出节点的左孩子入队，再将右孩子入队（入队前先判断是否有）  
5. 重复3——4，直到队列为空  
### 求一颗二叉树的宽度
二叉树的宽度即宽度优先遍历时，节点最多的那一层的节点个数。  
【解题思路】在二叉树宽度优先遍历的基础上，想办法统计每一层的节点数。   
1. 申请一个map，记录每个节点所在的层数（初始化根节点为第1层）  
2. 申请一个变量，记录当前层（初始值为1）
3. 申请一个变量，记录每一层节点个数（初始值为0）  
4. 申请一个变量，记录最大宽度（初始值为系统最小值）   
5. 接下来参考上面二叉树宽度优先遍历的步骤，以下说的第几步都是上面的步骤。  
6. 上面第3步弹出节点时，同时从map中取出该节点所在层数，如果所在层数是当前层，那么该层节点个数+1，如果不是当前层，说明来到了下一层，当前层数+1，此时比较该层节点个数和最大宽度，谁大将谁保存到最大宽度这个变量中，此时新的这一层节点个数为1   
7. 上面第4步时，将左孩子、右孩子入队时，也将左孩子、右孩子所在层数加入map中
## 02二叉搜索树
【概念】二叉搜索树也叫二叉查找树、有序二叉树，是指一颗空树或具有下列性质的二叉树：   
1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
3. 任意节点的左、右子树也分别为二叉查找树；   

【题目】判断一颗二叉树是否为二叉搜索树   
【解题思路】    
【方案一】
利用二叉树的中序遍历，如果为升序，则是二叉搜索树。     
方案1.1：改造递归中序遍历方法    
方案1.2：改造非递归中序遍历方法       
【方案二】使用递归方法判断，这种方法适合下列大多数二叉树的判断，因此称为”套路法“。   
1. 先判断左子树是不是二叉搜索树，如果是往下执行，不是返回false   
2. 再判断右子树是不是二叉搜索树，如果是往下执行，不是返回false
3. 如果左子树的最大值>=当前节点的值，则不是二叉搜索树，返回false  
4. 如果当前节点的值>=右子树的最小值，则不是二叉搜索树，返回false
5. 注意观察1——4步，因为递归调用所有分支的处理逻辑一样，返回值也是同一个类型，因此我们需要定义子方法的返回值：是否为二叉搜索树(boolean)、子树的最大值、最小值
## 03完全二叉树
【概念】在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree）。   
【题目】判断一颗二叉树是否为完全二叉树  
【解题思路】  
利用二叉树的宽度优先遍历，在遍历的过程中如果发生如下两个情况中的任何一个，就不是完全二叉树，否则就是完全二叉树：   
1. 当任何一个节点，有右孩子但没有左孩子时，不是完全二叉树   
2. 当某节点出现左右孩子不全时，该节点的下一层就应该是叶子节点，即下一层的左右孩子都为null，如果满足条件，就不是完全二叉树     
## 04满二叉树 
【概念】除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。
【性质】如果一颗二叉树的深度是K，节点个数是N，如果 N=2^K -1，那么这颗二叉树是满二叉树。反之亦然。    
【解题思路】   
【方案一】使用套路法解题

## 05平衡二叉树  
【概念】平衡二叉搜索树（英语：Balanced Binary Search Tree）是一种结构平衡的二叉搜索树，它是一种每个节点的左右两子树高度差都不超过1的二叉树。它能在O(logN)内完成插入、查找和删除操作，最早被发明的平衡二叉搜索树为AVL树。常见的平衡二叉搜索树有：   
* AVL树
* 红黑树
* Treap
* 节点大小平衡树      

【题目】判断一颗二叉树是否为平衡二叉树    
【解题思路】可以考虑使用”套路法“来解。    
1. 首先判断左子树是平衡二叉树   
2. 在判断右子树是平衡二叉树   
3. 左子树高度-右子树高度的绝对值不能超过1   
4. 满足以上条件，就是平衡二叉树  

## 06 练习题
### 给定二叉树的两个节点node1和node2，找到它们的最低公共祖先节点
【解题方案】   
【方案一】      
1. 将所有节点及其对应的父节点放到map中
2. 新建一个Set集合，从node1开始向上遍历，将node1、node1的父、父的父、直到head节点全部放进Set集合中   
3. 从node2开始向上遍历，并检查是否在Set集合中，如果在，那么该节点就是node1和node2的最低公共祖先

【方案二】   
1. 两个节点的最低公共祖先有两种情况：   
1.1 node1是node2的最低公共祖先，或者node2是node1的最低公共祖先   
1.2 node1、node2不互为公共祖先，向上找，找到公共祖先   
2. 代码如lowestAncestor2   
### 在二叉树中找到一个节点的后继节点     
现在有一种新的二叉树节点类型如下：   
```java
    public class Node1 {
        public int value;
        public Node1 left;
        public Node1 right;
        public Node1 parent;

        public Node1(int value) {
            this.value = value;
        }
    }
```    
该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一颗Node1类型的节点组成的二叉树，树中每个节点的parent指针都正确的指向自己的父节点，头节点的parent指向null。   
只给一个在二叉树中的某个节点node，请实现返回node节点的后继节点的函数。   
在二叉树的中序遍历的序列中，node的下一个节点叫做node的后继节点。

【解题方案】   
【方案一】使用中序遍历，将遍历结果保存到数组中或其他数据结构中，然后查找  
【方案二】  
1. 如果节点x有右子树，那么它的后继结点就是右子树上最左的叶子节点   
2. 如果节点x没有右子树，它的后继结点有两种情况：   
2.1 如果x不是最后一个节点，那么它的后继节点是一路往上找，直到碰到一个节点它是某个节点y的右子树，那么y就是x的后继
2.2 如果x是最后一个节点，它的后继节点是null   
### 二叉树的序列化和反序列化



