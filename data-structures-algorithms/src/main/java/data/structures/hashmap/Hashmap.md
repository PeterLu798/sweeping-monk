# 哈希函数和哈希表
## 哈希函数
### 哈希函数的特征
1. 函数的输入可以是无穷大，但是输出是有限长度
2. 相同的输入一定会有相同的输出，即哈希函数不存在任何随机性
3. 不同的输入有可能会有相同的输出，这种现象叫做哈希碰撞。哈希碰撞的概率非常非常低
4. 均匀分布：即使是具有一定规律的元素进入哈希表中，哈希函数也会通过一定手段将其均匀分布在整个哈希表中
5. 如果哈希函数的计算结果在区域上均匀分布，那么这些计算结果 %m 之后，其结果也会在0 ~ m-1范围上均匀分布
### 题目一
在一个大文件中有40亿个无符号整数，每个整数取值的范围是0~42亿之间。现在要在1G的内存中统计出出现次数最多的数，请设计程序实现之。      
【解题过程】
1. 40亿个数如果全部放在HashMap中，最差的情况是需要32G个内存，因此直接使用HashMap不可取
2. 将这些数字，每一个求哈希值，在将哈希值 %100，得到m1、m2、m3...mN，m的范围一定在0~99上
3. 将原数值记录在m1~m99这些文件中
4. 分别统计m1~m99文件上出现次数最多的数字
### 题目二：哈希表的实现


### 题目三
设计一种结构，在该结构中有如下三个功能：
1. insert(key): 将某个key加入到该结构，做到不重复加入
2. delete(key): 将原本在结构中的某个key删除
3. getRandom(): 等概率随机返回结构中的任何一个key     

要求：insert、delete、getRandom的时间复杂度都是O(1)   
代码：[RandomPool.java](RandomPool.java)
### 题目四：布隆过滤器
#### 位图
1. 1B = 8 bit
2. 一个int占4B, 一个long占8B
3. bit(位)，表示二进制位
4. B即byte，字节。是计算机计算存储空间大小的最小单位
```java
public class BitMap {
    public static void main(String[] args) {
        //下面申明的arr最多可以容纳 8*4*10 = 320bit，也就是说最多可以容纳320个位
        int[] arr = new int[10];
        //获取第i位的状态，如获取第178bit的状态
        int i = 178;
        int numIndex = i / 32;
        int bitIndex = i % 32;
        int state = (arr[numIndex] >> bitIndex) & 1;
        //把第i位的状态改成1
        arr[numIndex] = arr[numIndex] | (1 << bitIndex);
        //把第i位的状态改成0
        arr[numIndex] = arr[numIndex] & (~(1 << bitIndex));
    }
}
```
#### 布隆过滤器适用场景
1. 亿级以上数据的黑白名单
2. 判断某一个数据是否在一个庞大的数据集中
#### 布隆过滤器设计思路
1. 假设数据集的样本量为n，允许的失误率为p。
2. 先将数据集中的每条数据用k个哈希函数计算哈希值，然后将这k个哈希值分别 %m (m单位为bit)，得到k个值，这k个值一定在0~m-1范围内   
3. 将这k个值的状态在位图m中标记出来
4. 查询x在不在数据集中：将x也分别用k个哈希函数计算哈希值，然后查询位图m中这k个位置的状态，如果状态都为1，那么说明x在数据集中
5. 布隆过滤器有一定的误差，这个误差是，假如x不在集合中，会误计算在集合中。但是假如x在集合中，布隆过滤器一定不会得出不在的结果。
6. 式中的p、k、m如何计算：     
6.1 数据样本量n是确定的，失误率p是可以事先规定好的，那么来计算k、m的值：    
6.2 m = -(n * ln(p)) / (ln(2))^2   
6.3 k = ln(2) * m/n = 0.7 * m/n个     
6.4 p = (1 - e^(-n*k/m))^k
