# 哈希函数和哈希表
## 哈希函数
### 哈希函数的特征
1. 函数的输入可以是无穷大，但是输出是有限长度
2. 相同的输入一定会有相同的输出，即哈希函数不存在任何随机性
3. 不同的输入有可能会有相同的输出，这种现象叫做哈希碰撞。哈希碰撞的概率非常非常低
4. 均匀分布：即使是具有一定规律的元素进入哈希表中，哈希函数也会通过一定手段将其均匀分布在整个哈希表中
5. 如果哈希函数的计算结果在区域上均匀分布，那么这些计算结果 %m 之后，其结果也会在0 ~ m-1范围上均匀分布
### 题目一
在一个大文件中有40亿个无符号整数，每个整数取值的范围是0~42亿之间。现在要在1G的内存中统计出出现次数最多的数，请设计程序实现之。      
【解题过程】
1. 40亿个数如果全部放在HashMap中，最差的情况是需要32G个内存，因此直接使用HashMap不可取
2. 将这些数字，每一个求哈希值，在将哈希值 %100，得到m1、m2、m3...mN，m的范围一定在0~99上
3. 将原数值记录在m1~m99这些文件中
4. 分别统计m1~m99文件上出现次数最多的数字
### 题目二：哈希表的实现


### 题目三
设计一种结构，在该结构中有如下三个功能：
1. insert(key): 将某个key加入到该结构，做到不重复加入
2. delete(key): 将原本在结构中的某个key删除
3. getRandom(): 等概率随机返回结构中的任何一个key     

要求：insert、delete、getRandom的时间复杂度都是O(1)   
代码：[RandomPool.java](RandomPool.java)
### 题目四：布隆过滤器
#### 位图
1. 1B = 8 bit
2. 一个int占4B, 一个long占8B
3. bit(位)，表示二进制位
4. B即byte，字节。是计算机计算存储空间大小的最小单位
```java
public class BitMap {
    public static void main(String[] args) {
        //下面申明的arr最多可以容纳 8*4*10 = 320bit，也就是说最多可以容纳320个位
        int[] arr = new int[10];
        //获取第i位的状态，如获取第178bit的状态
        int i = 178;
        int numIndex = i / 32;
        int bitIndex = i % 32;
        int state = (arr[numIndex] >> bitIndex) & 1;
        //把第i位的状态改成1
        arr[numIndex] = arr[numIndex] | (1 << bitIndex);
        //把第i位的状态改成0
        arr[numIndex] = arr[numIndex] & (~(1 << bitIndex));
    }
}
```
#### 布隆过滤器适用场景
1. 亿级以上数据的黑白名单
2. 判断某一个数据是否在一个庞大的数据集中
#### 布隆过滤器设计思路
1. 假设数据集的样本量为n，允许的失误率为p。
2. 先将数据集中的每条数据用k个哈希函数计算哈希值，然后将这k个哈希值分别 %m (m单位为bit)，得到k个值，这k个值一定在0~m-1范围内   
3. 将这k个值的状态在位图m中标记出来
4. 查询x在不在数据集中：将x也分别用k个哈希函数计算哈希值，然后查询位图m中这k个位置的状态，如果状态都为1，那么说明x在数据集中
5. 布隆过滤器有一定的误差，这个误差是，假如x不在集合中，会误计算在集合中。但是假如x在集合中，布隆过滤器一定不会得出不在的结果。
6. 式中的p、k、m如何计算：     
6.1 数据样本量n是确定的，失误率p是可以事先规定好的，那么来计算k、m的值：    
6.2 m = -(n * ln(p)) / (ln(2))^2   
6.3 k = ln(2) * m/n = 0.7 * m/n个     
6.4 p = (1 - e^(-n*k/m))^k
### 题目五：一致性哈希原理
分布式数据库需要解决的一个关键问题是，路由一致性问题，即同一份数据，它的所有操作（主要是读和写）如何能落在相同的机器上。    
假设有0、1、2三台数据库机器，如何让数据均衡的分布在这三台机器上？经典解法如下：   
1. 写逻辑：将数据求哈希值，然后 %3，得到数字n，n一定落在0、1、2这三台中的一台。  
2. 读逻辑也是一样，求哈希值，%3     

关键问题如下：  
1. 如何让key均匀的分布在三台机器上，关键点就是你的key一定要分布足够均匀，比如身份证号、自增Id等等
2. 如何让冷热数据均匀的分布在各个机器上，依赖于第1点，如果你的key足够均匀，那么算出来的冷热数据的哈希值在理论上一定会均匀的分布在各个机器上的
3. 机器如何扩充？如何缩减？   

为了解决第3个问题，就不能用经典解法，即不能用 %n 的办法来选择机器。提供新的解题思路如下：
1. 使用哈希一致性原理来分割数据，即采用一个哈希函数来计算每条数据的哈希值，如采用md5算法，那么得到的哈希值范围就在0~2^64-1之间
2. 将n台机器也根据不同的特征（如ip地址、hostname等）计算哈希值，那么这n台机器的哈希值也在0~2^64-1范围内
3. 任何一条数据进来之后，根据哈希值首先计算大于等于这条数据最左的机器哈希值是哪台（可以用二分法等），确定了机器
4. 扩充机器：当添加了一台机器x，计算出它的哈希值 h(x),此时只需要将小于h(x)最右的那个节点到h(x)的部分数据拷贝到新的机器上，同时新加一台负载
5. 缩减机器也同理4       

这个新的方案也同样带来了新的问题：
1. 如何保证这n台机器能均匀的承接所有数据
2. 增加/缩减了机器之后，这个均衡性就被打破，如何解决？  

思路就是虚拟节点。




